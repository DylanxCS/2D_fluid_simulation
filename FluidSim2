# Dylan Swanson
# FluidSim PT.2
# Starting June 2, 2024
# Reference: https://mikeash.com/pyblog/fluid-simulation-for-dummies.html

import pygame
import numpy as np
import math
pygame.init()

# Set up the window
N = 512
screen = pygame.display.set_mode((N,N))
pygame.display.set_caption("Fluid Simulator")
running = True
while running:
    # Handle events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
    pygame.display.flip()
pygame.quit()

# Initialize variables
dt = 0.1
diffusion = 0.01
viscosity = 0.01

# Initialize arrays
X = np.zeros((N,N), dtype=float)
Y = np.zeros((N,N), dtype=float)
X0 = np.zeros((N,N), dtype=float)
Y0 = np.zeros((N,N), dtype=float)
Vx = np.zeros((N,N), dtype=float)
Vy = np.zeros((N,N), dtype=float)
Vx0 = np.zeros((N,N), dtype=float)
Vy0 = np.zeros((N,N), dtype=float)
density = np.zeros((N,N), dtype=float)
density0 = np.zeros((N,N), dtype=float)

def add_density(x, y, amount):
    density[x,y] += amount

def add_velocity(x, y, amount_x, amount_y):
    X[x,y] += amount_x
    Y[x,y] += amount_y

# 1 = sides, 2 = tops, 0 = corners
def walls(array, t, N):#3 = checks z's, 2 = y's, 1 = x's
    if (t == "top"):
        array[0] = -array[1]
        array[N-1] = -array[N-2]
    if (t == "side"):
        array[:,0] = -array[:,1]
        array[:,N-1] = -array[:,N-2]
    # Corners
    array[0,0] = 0.5*(array[1,0]+array[0,1])
    array[0,N-1] = 0.5*(array[1,N-1]+array[0,N-2])
    array[N-1,0] = 0.5*(array[N-2,0]+array[N-1,1])
    array[N-1,N-1] = 0.5*(array[N-1,N-2]+array[N-2,N-1])
        
def solver(array, array0, a, c, iter, t, N):
    for k in range(iter):
        for i in range(1,N-1):#may be out of bounds - we want the box inside the edges
            for j in range(1,N-1):
                array[i,j] = (array0[i,j] + 
                                a*(array[i+1,j] + array[i-1,j]
                                + array[i,j+1] + array[i,j-1])
                                ) * (1/c)
        walls(array,t,N)

def diffuse(array, array0, diff, dt, iter, t, N): #check necessity of these. maybe they can be stored as global variables
    a = dt * diff * (N-2)**2
    solver(array, array0, a, 1+6*a, iter, N)

def project(Vx, Vy, p, div, iter, N):
    for i in range(1,N-1):
        for j in range(1,N-1):
            div[i,j] = -0.5 * (Vx[i+1,j] - Vx[i-1,j]
                                + Vy[i,j+1] - Vy[i,j-1])/N
            p[i,j] = 0
    walls(0,div,N)
    walls(0,p,N)
    solver(p,div,1,6,iter,0,N)
    
    for i in range(1,N-1):
        for j in range(1,N-1):
            Vx -= (0.5 * (p[i+1,j] - p[i-1,j]) * N)
            Vy -= (0.5 * (p[i,j+1] - p[i,j-1]) * N)
    walls("side",Vx,N)
    walls("top",Vy,N)

def advect(t, array, array0, Vx, Vy, dt, N):
    dtx, dty, dtz = dt * (N-2)
    Nfloat = N
    for i,ifloat in zip(range(1,N-1),range(1,N-1)):
        for j,jfloat in zip(range(1,N-1),range(1,N-1)):
            tmp1 = dtx * Vx[i,j]
            tmp2 = dty * Vy[i,j]
            x = ifloat - tmp1 #maybe x is global variable
            y = jfloat-tmp2

            if(x < 0.5): x = 0.5
            if(x > Nfloat+0.5): x = Nfloat+0.5
            i0 = math.floor(x)
            i1 = i0 + 1
            if(y < 0.5): y = 0.5
            if(y > Nfloat+0.5): y = Nfloat+0.5
            j0 = math.floor(y)
            j1 = j0 + 1

            s1 = x - i0
            s0 = 1 - s1
            t1 = y - j0
            t0 = 1 - t1

            i0i = i0
            i1i = i1
            j0i = j0
            j1i = j1

            array[i,j] = (
                (s0 * (t0 * array0[i0i, j0i]
                    + t1 * array[i0i, j1i]))
                + s1 * (t0 * array0[i1i,j0i] 
                    + t1 * array0[i1i,j1i]))
    walls(t,array,N)
